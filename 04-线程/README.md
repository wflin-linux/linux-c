# 多线程

[**推荐阅读博文：**](https://www.cnblogs.com/xiehongfeng100/p/4620852.html)

## 进程与线程:

​		典型的UNIX/Linux进程可以看成只有一个控制线程：一个进程在同一时刻只做一件事情。有了多个控制线程后，**在程序设计时可以把进程设计成在同一时刻做不止一件事**，**每个线程各自处理独立的任务。进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。**在**面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。**程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。（程序是静态的概念，进程是运行起来的程序，是动态的概念）

​		**进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响**，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程没有单独的地址空间，**一个线程死掉就等于整个进程死掉**（理解 ：**<u>这要看怎么去理解死掉这个词，如果是正常的线程中止或者死循环这样的死掉，对进程的其他线程是没有影响的。如果是段错误除数为零等这类意外的死掉，默认情况就会中止整个进程，如果安装了对应的信号处理函数，就会触发信号处理调用</u>**），**所以多进程的程序要比多线程的程序健壮**，但在进程切换时，耗费资源较大，效率要差一些。但**对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程**。

总结：从函数调用上来说，进程创建使用fork()操作；线程创建使用clone()操作。

## 使用线程的好处

从上面我们知道了进程与线程的区别，其实这些区别也就是我们使用线程的理由。总的来说就是：**进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间）**。

　　使用多线程的**理由之一**是和进程相比，它是一种非常**"节俭"的多任务操作方式**。我们知道，在Linux系统下，**启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段**，这是一种"昂贵"的多任务工作方式。**而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。**据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。

　　使用多线程的**理由之二**是**线程间方便的通信机制**。**对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便**。**线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便**。当然，数据的共享也带来其他一些问题，有**的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击**，这些正是编写多线程程序时最需要注意的地方。

​		除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：

- **提高应用程序响应**。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。
- **使多CPU系统更加有效**。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
- **改善程序结构**。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

## Linux 上线程开发 API 概要

​		多线程开发在 Linux 平台上已经有成熟的 **pthread**  库支持(第三方库)。其涉及的**多线程开发的最基本概念主要包含三点：线程，互斥锁，条件**。其中，**线程操作又分线程的创建，退出，等待** 3 种。**互斥锁则包括 4  种操作，分别是创建，销毁，加锁和解锁**。**条件操作有 5  种操作：创建，销毁，触发，广播和等待**。其他的一些线程扩展概念，如信号灯等，都可以通过上面的三个基本元素的基本操作封装出来。详细请见下表：

![](https://images0.cnblogs.com/blog2015/570460/201507/041632598968698.png)

**1.线程创建**

```c
#include <pthread.h>
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);
// 返回：若成功返回0，否则返回错误编号
```

​		当**[pthread_create](http://man7.org/linux/man-pages/man3/pthread_create.3.html)成功**返回时，由**tidp指向的内存单元被设置为新创建线程的线程ID**。attr参数用于定制各种不同的线程属性，暂可以把它设置为NULL，以创建默认属性的线程。

​		新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。**如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg参数传入**。



**2. 线程退出**

　　单个线程可以通过以下三种方式退出，在**不终止整个进程**的情况下**停止它的控制流**：

　　1）**线程只是从启动例程中返回，返回值是线程的退出码**。

　　2）**线程可以被同一进程中的其他线程取消**。

　　3）**线程调用pthread_exit**：

```c
#include <pthread.h>
int pthread_exit(void *rval_ptr);
```

　　rval_ptr是一个无类型指针，与传给启动例程的单个参数类似。进程中的其他线程可以通过调用pthread_join函数访问到这个指针。



**3. 线程等待**

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);
// 返回：若成功返回0，否则返回错误编号
```

　　**调用这个函数的线程将一直阻塞**，直到**指定的线程调用 pthread_exit**、**从启动例程中返回或者被取消**。如果例程**只是从它的启动例程返回i，rval_ptr 将包含返回码**。**如果线程被取消，由rval_ptr指定的内存单元就置为PTHREAD_CANCELED。**

　　可以通过调用**pthread_join自动把线程置于分离状态**，**这样资源就可以恢复**。如果线程已经处于分离状态，pthread_join调用就会失败，返回EINVAL。

　　如果**对线程的返回值不感兴趣，可以把rval_ptr置为NULL**。在这种情况下，**调用pthread_join函数将等待指定的线程终止**，**但并不获得线程的终止状态。**

