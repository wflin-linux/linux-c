# 多线程

[**推荐阅读博文：**](https://www.cnblogs.com/xiehongfeng100/p/4620852.html)

## 进程与线程:

​		典型的UNIX/Linux进程可以看成只有一个控制线程：一个进程在同一时刻只做一件事情。有了多个控制线程后，**在程序设计时可以把进程设计成在同一时刻做不止一件事**，**每个线程各自处理独立的任务。进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。**在**面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。**程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。（程序是静态的概念，进程是运行起来的程序，是动态的概念）

​		**进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响**，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程没有单独的地址空间，**一个线程死掉就等于整个进程死掉**（理解 ：**<u>这要看怎么去理解死掉这个词，如果是正常的线程中止或者死循环这样的死掉，对进程的其他线程是没有影响的。如果是段错误除数为零等这类意外的死掉，默认情况就会中止整个进程，如果安装了对应的信号处理函数，就会触发信号处理调用</u>**），**所以多进程的程序要比多线程的程序健壮**，但在进程切换时，耗费资源较大，效率要差一些。但**对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程**。

总结：从函数调用上来说，进程创建使用fork()操作；线程创建使用clone()操作。

## 使用线程的好处

从上面我们知道了进程与线程的区别，其实这些区别也就是我们使用线程的理由。总的来说就是：**进程有独立的地址空间，线程没有单独的地址空间（同一进程内的线程共享进程的地址空间）**。

　　使用多线程的**理由之一**是和进程相比，它是一种非常**"节俭"的多任务操作方式**。我们知道，在Linux系统下，**启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段**，这是一种"昂贵"的多任务工作方式。**而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。**据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。

　　使用多线程的**理由之二**是**线程间方便的通信机制**。**对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便**。**线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便**。当然，数据的共享也带来其他一些问题，有**的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击**，这些正是编写多线程程序时最需要注意的地方。

​		除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：

- **提高应用程序响应**。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。
- **使多CPU系统更加有效**。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
- **改善程序结构**。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

## Linux 上线程开发 API 概要

​		多线程开发在 Linux 平台上已经有成熟的 **pthread**  库支持(第三方库)。其涉及的**多线程开发的最基本概念主要包含三点：线程，互斥锁，条件**。其中，**线程操作又分线程的创建，退出，等待** 3 种。**互斥锁则包括 4  种操作，分别是创建，销毁，加锁和解锁**。**条件操作有 5  种操作：创建，销毁，触发，广播和等待**。其他的一些线程扩展概念，如信号灯等，都可以通过上面的三个基本元素的基本操作封装出来。详细请见下表：

![](https://images0.cnblogs.com/blog2015/570460/201507/041632598968698.png)

**1.线程创建**

```c
#include <pthread.h>
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);
// 返回：若成功返回0，否则返回错误编号
```

​		当**[pthread_create](http://man7.org/linux/man-pages/man3/pthread_create.3.html)成功**返回时，由**tidp指向的内存单元被设置为新创建线程的线程ID**。attr参数用于定制各种不同的线程属性，暂可以把它设置为NULL，以创建默认属性的线程。

​		新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针参数arg。**如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg参数传入**。



**2. 线程退出**

　　单个线程可以通过以下三种方式退出，在**不终止整个进程**的情况下**停止它的控制流**：

　　1）**线程只是从启动例程中返回，返回值是线程的退出码**。

　　2）**线程可以被同一进程中的其他线程取消**。

　　3）**线程调用pthread_exit**：

```c
#include <pthread.h>
int pthread_exit(void *rval_ptr);
```

　　rval_ptr是一个无类型指针，与传给启动例程的单个参数类似。进程中的其他线程可以通过调用pthread_join函数访问到这个指针。



**3. 线程等待**

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);
// 返回：若成功返回0，否则返回错误编号
```

　　**调用这个函数的线程将一直阻塞**，直到**指定的线程调用 pthread_exit**、**从启动例程中返回或者被取消**。如果例程**只是从它的启动例程返回i，rval_ptr 将包含返回码**。**如果线程被取消，由rval_ptr指定的内存单元就置为PTHREAD_CANCELED。**

　　可以通过调用**pthread_join自动把线程置于分离状态**，**这样资源就可以恢复**。如果线程已经处于分离状态，pthread_join调用就会失败，返回EINVAL。

　　如果**对线程的返回值不感兴趣，可以把rval_ptr置为NULL**。在这种情况下，**调用pthread_join函数将等待指定的线程终止**，**但并不获得线程的终止状态。**

## 与互斥锁相关API

　　**互斥量（mutex）从本质上来说是一把锁**，在**访问共享资源前对互斥量进行加锁**，在**访问完成后释放互斥量上的锁**。对互斥量进行**加锁后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁**。**如果释放互斥锁时有多个线程阻塞**，所有在该互斥锁上的阻塞线程都会变成可运行状态，**第一个变为可运行状态的线程可以对互斥量加锁**，**其他线程将会看到互斥锁依然被锁住**，只能回去等待它重新变为可用。在这种方式下，每次只有一个线程可以向前运行。在设计时需要规定所有的线程必须遵守相同的数据访问规则。只有这样，互斥机制才能正常工作。操作系统并不会做数据访问的串行化。

　　**互斥变量用pthread_mutex_t数据类型**表示。在使用互斥变量前必须对它进行初始化，可以把它置为**常量PTHREAD_MUTEX_INITIALIZER**（只对静态分配的互斥量），也可以通过调用pthread_mutex_init函数进行初始化。如果动态地分配互斥量（例如通过调用malloc函数），那么在释放内存前需要调用pthread_mutex_destroy。

　**1.  创建及\**销毁\**互斥锁**

```c
#include <pthread.h>
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t* mutex);
// 返回：若成功返回0，否则返回错误编号
```

　　要用默认的属性初始化互斥量，只需把attr设置为NULL。　　

　　**2. 加锁及解锁**

```c
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
// 返回：若成功返回0，否则返回错误编号
```





## 编程实战

**编译多线程文件的方法：gcc name.c -lpthread.c**

1. **create_pthread()**

   ```c
   ret = pthread_create(&t1,NULL,funct1,(void *)&parm);   
   // 第一个参数是 线程代号t1  ,第二个参数是线程记录线程创建时的相关信息，一般使用NULL 不做记录。第三个是对该线程传入的操作函数。最后一个参数，传参时如果只是传递一个参数(parm )，就传入基本的char，int....，若果传入多个参数就需要传入结构体
   
   (unsigned long)pthread_self()	// 打印线程的id，这个线程号返回值是长整型
    // 注意点：其他线程的打印信息应该在主线成结束之前打印出来，如果主线程在其他线程之前结束，那么其他线程的打印信息就不会打印出来，所以如果其他线程没有打印出改打印的信息，那么有可能就是主线程提前退出，可以测试 案例 Create_pthread.c 中的while(1) 注释，查看区别
   ```

   

2. **join_pthread()**

   ```c
   // 在退出线程之前把数据传入主线程时，需要的是用static关键字对线程中地址进行限定，用来由主线程中相关的地址指向其他线程的数据地址用来获取其他线程的数据
   void pthread_exit(void *retval);
   // 第二个参数是一个void 类型的二级指针。所以转换指针类型时一定要注意转换，不然会产生段错误（core dump）
    int pthread_join(pthread_t thread, void **retval);
   // 多个线程的时候调用 pthread_exit() 可能也不会让线程退出，比如多个线程操作同一个数据，当数据达到某一个只时退出，但是线程的启动目前是随机的，所以不一定那个数值达到退出时，恰好被该线程调用
   ```

   

3. **互斥锁**

   ```c
   int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);			//创建锁
   int pthread_mutex_destroy(pthread_mutex_t mutex);	//销毁锁
   int pthread_mutex_lock(pthread_mutex_t mutex);	//上锁
   int pthread_mutex_unlock(pthread_mutex_t mutex);	// 解锁
   // 锁就是让一个线程的代码全部执行完成之后再执行其他的线程的代码。并不是锁定线程执行的顺序，线程的启动还是随机的
   ```

   

4. **造成死锁原因**

   首先程序中必须有两把锁，当线程1获得一把锁的时候还想要获得另一把锁，线程2手中拿着线程1想要获得的那把锁，同时线程2也想拿到线程1的那把锁。然后都不能往下去解锁，造成线程死锁 案例请看 	mutex_die_Pthread.c

5. 

6. 

7. 

8. 
